<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- JS -->
    <!-- Bootstrap styling -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <!-- Mapbox, mapbox-draw, turf -->
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.13.0/mapbox-gl.js'></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.js'></script>
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
    <!-- Jquery -->
    <script src="https://code.jquery.com/jquery-3.5.1.js" integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=" crossorigin="anonymous"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.13.0/mapbox-gl.css' rel='stylesheet' />
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.css' type='text/css'/>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .dropdown {
            margin-right: 0.5rem;
        }

        .dropdown-menus {
            position: absolute;
            display: flex;
            top: 1rem;
            left: 1rem;
        }

    </style>
</head>
<body>

<style>

</style>

<div id='map'></div>

<div class="dropdown-menus">
    <select id="select-bird" class="dropdown">
        <option value="none">Select Bird</option>
        <option value="ameavo">American Avocet</option>
        <option value="bknsti">Black-Necked Stilt</option>
    </select>
    <select id="select-time" class="dropdown">
        <option value="none">Select Variable</option>
        <option value="ra">Relative Abundance</option>
        <option value="pop">Percent of Population</option>
    </select>
    <div class="slider-container">
        <input type="range" min="11" max="13" value="11" class="slider" id="select-week">
    </div>
</div>

<script>
    mapboxgl.accessToken = 'pk.eyJ1IjoibGF1cmVub2xkaGFtMTIwMiIsImEiOiJjaW55dm52N2gxODJrdWtseWZ5czAyZmp5In0.YkEUt6GvIDujjudu187eyA';

    // birds - ameavo, bknsti
    // vars - relative abundance, percent of population
    // time - 3 weeks

    // bknsti pop week 11 - laurenoldham1202.5fck411z
    // bknsti pop week 12 - laurenoldham1202.7j0ypz8w
    // bknsti pop week 13 - laurenoldham1202.0bgqnmvd
    // ameavo pop week 11 - laurenoldham1202.cq1dlt02
    // ameavo pop week 12 - laurenoldham1202.bcl9t1ic
    // ameavo pop week 13 - laurenoldham1202.3xrib0y6

    // let bird = 'bknsti';
    // let time = 'nonbreeding';

    let week = 11;
    let bird = '';
    let time = '';

    let selectedLayer = undefined;
    let drawnPolygon = undefined;

    const tileMap = {
        bknsti_pop_11: '5fck411z',
        bknsti_pop_12: '7j0ypz8w',
        bknsti_pop_13: '0bgqnmvd',
        ameavo_pop_11: 'cq1dlt02',
        ameavo_pop_12: 'bcl9t1ic',
        ameavo_pop_13: '3xrib0y6',
    };

    // TODO: Find out how weekly data will be accessed (will users be interested in just one week at a time, or how trends occur week over week?)
    // Should all birds/variables have the same legend/scale, or should it be custom for each one?

    function updateTileLayer() {

        if (bird !== '' && time !== '') {
            const layer = `${bird}_${time}_${week}`;
            console.log(layer);

            Object.keys(tileMap).forEach(id => {
                if (id === layer) {
                    map.setLayoutProperty(id, 'visibility', 'visible');
                } else {
                    map.setLayoutProperty(id, 'visibility', 'none');
                }
            });
        }
    }

    $('#select-time').on('change', (e) => {
        time = e.target.value;
        updateTileLayer();
    });

    $('#select-bird').on('change', (e) => {
        // console.log(e.target.value);
        bird = e.target.value;
        updateTileLayer();
    });

    // changet to 'change' event to only load on final resting spot and not every tick
    $('#select-week').on('input', (e) => {
        week = e.target.value;
        updateTileLayer();
    });
    //
    // $('#select-time').on('change', (e) => {
    //     const selectedTime = e.target.value;
    //     selectedLayer = `${bird}_${e.target.value}`;
    //
    //     if (drawnPolygon) {
    //         // console.log('calc');
    //         selectTiles();
    //     }
    //
    //     Object.keys(tileMap).forEach(time => {
    //         // TODO create fn for returning layerName
    //         const layerName = `${bird}_${time}`;
    //        if (selectedTime === time) {
    //            map.setLayoutProperty(layerName, 'visibility', 'visible');
    //        } else {
    //            // console.log('turn off ', time);
    //            map.setLayoutProperty(layerName, 'visibility', 'none');
    //
    //        }
    //     });
    //
    //     // Object.entries(tileMap).forEach(([timeKey, tileId]) => {
    //     //     if
    //     // });
    //
    // });

    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v9',
        center: [-75, 10], // starting position [lng, lat]
        zoom: 1, // starting zoom
    });

    map.on('load', () => {
        // https://laurenoldham1202.github.io/countries-vector-tiles/

        // http://localhost:8080/data/bknsti_pop/{z}/{x}/{y}.pbf

        const loc = location.origin + location.pathname + 'tiles/{z}/{x}/{y}.pbf';

        // TODO see if www/vectortiles is needed
        map.addSource('bknsti2', {
            type: 'vector',
            // scheme: 'xyz',  // required for proper display of vector tiles
            // `countries:opengeo:countries` are the workspace (countries) and layer name (opengeo:countries) as uploaded in geoserver
            tiles: [loc],
            // minZoom: 0,
            maxZoom: 15,
        });

        console.log(loc);
        console.log(map.getSource('bknsti2'));

        map.addLayer({
            id: 'bknsti2',
            type: 'fill',
            source: 'bknsti2',
            'source-layer': 'ameavo_ra',  // `title` from geoserver
            paint: {
                'fill-color': 'red',
                'fill-opacity': 0.25,
            }
        });
        console.log(map.getLayer('bknsti2'));

        map.on('click', 'bknsti2', (e) => {
            console.log(e.features[0].properties);
        });



        // TODO Deploy versions for github hosting (remote), github hosting (local/offline) and mapbox hosting, document
        // TODO Check in with Tom about google maps API
        // TODO Ask about other data vis packages currently in use - or do I need to figure that out?

        //
        // // TODO see if www/vectortiles is needed
        // map.addSource('bknsti3', {
        //     type: 'vector',
        //     // scheme: 'tms',  // required for proper display of vector tiles
        //     // `countries:opengeo:countries` are the workspace (countries) and layer name (opengeo:countries) as uploaded in geoserver
        //     // TODO create Git tutorials for serving remotely with github pages, serving PBFs from local directory, tileServerGl, mapTiler?
        //     tiles: ['https://laurenoldham1202.github.io/countries-vector-tiles/graticules/{z}/{x}/{y}.pbf'],
        //     // minZoom: 0,
        //     maxZoom: 15,
        // });
        // console.log(map.getSource('bknsti3'));
        //
        // map.addLayer({
        //     id: 'bknsti3',
        //     type: 'line',
        //     source: 'bknsti3',
        //     'source-layer': 'graticules',  // `title` from geoserver
        //     paint: {
        //         'line-color': 'blue',
        //     }
        // });
        // console.log(map.getLayer('bknsti2'));
        //
        // map.on('click', 'bknsti2', (e) => {
        //     console.log(e.features[0].properties);
        // });


        // // TODO see if www/vectortiles is needed
        // map.addSource('bknsti2', {
        //     type: 'vector',
        //     // scheme: 'tms',  // required for proper display of vector tiles
        //     // `countries:opengeo:countries` are the workspace (countries) and layer name (opengeo:countries) as uploaded in geoserver
        //     tiles: ['http://localhost:8080/data/ameavo-join/{z}/{x}/{y}.pbf'],
        //     // minZoom: 0,
        //     maxZoom: 15,
        // });
        // console.log(map.getSource('bknsti'));
        //
        // map.addLayer({
        //     id: 'bknsti2',
        //     type: 'fill',
        //     source: 'bknsti2',
        //     'source-layer': 'ameavo_pop_week12',  // `title` from geoserver
        //     paint: {
        //         'fill-color': 'red',
        //         'fill-opacity': 0.25,
        //     }
        // });
        // console.log(map.getLayer('bknsti2'));
        //
        // map.on('click', 'bknsti2', (e) => {
        //     console.log(e.features[0].properties);
        // });




        Object.entries(tileMap).forEach(([key, id]) => {

            const source = key.slice(0, 10);
            map.addSource(key, {
                type: 'vector',
                url: `mapbox://laurenoldham1202.${id}`
            });

            map.addLayer({
                id: key,
                type: 'fill',
                source: key,
                'source-layer': source,
                paint: {
                    'fill-color': ['interpolate', ['linear'], ['get', 'percent_of_population'],
                        0, 'rgba(255, 255, 255, 1)',
                        0.0001, '#fcfdbf',
                        0.0004, '#fc8761',
                        0.0008, '#b6367a',
                        0.0012, '#51127c',
                        0.0016, '#00004c',
                        0.002, '#00004c'
                    ],
                    'fill-opacity': 0.75,
                    'fill-outline-color': 'transparent',
                },
                layout: {
                    visibility: 'none',
                },
            });
        });



        // loadTiles();
        addDrawControl();
        onDraw();



        map.on('zoom', () => {
            // TODO Try to make zoom selection more seamless -
            // Tile layer changes and then selects on zoom, so there is a brief blip where the selected layer isn't visible
            if (drawnPolygon) {
                // selectTiles();
            }
        });

        // map.on('click', layerName, (e) => {
        //     console.log(e.features[0].properties);
        // });
    });


    function getLayerName(time) {
        return `${bird}_${time}`;
    }

    // // TODO Might need to make layerName a dynamic input
    // function loadTiles() {
    //
    //     Object.entries(tileMap).forEach(([timeKey, tileId]) => {
    //         const layerName = `${bird}_${timeKey}`;
    //
    //
    //
    //         map.addSource(layerName, {
    //             type: 'vector',
    //             url: `mapbox://laurenoldham1202.${tileId}`
    //         });
    //
    //         map.addLayer({
    //             id: layerName,
    //             type: 'fill',
    //             source: layerName,
    //             'source-layer': layerName,
    //             paint: {
    //                 // 'fill-color': ['interpolate', ['linear'], ['get', 'relative_abundance'],
    //                 //     0, 'rgba(255, 255, 255, 1)',
    //                 //     0.00001, '#fcfdbf',
    //                 //     0.5, '#fc8761',
    //                 //     1.5, '#b6367a',
    //                 //     3, '#51127c',
    //                 //     5, '#00004c',
    //                 //     120, '#000'
    //                 // ],
    //                 'fill-color': ['interpolate', ['linear'], ['get', 'percent_of_population'],
    //                     0, 'rgba(255, 255, 255, 1)',
    //                     0.0001, '#fcfdbf',
    //                     0.0004, '#fc8761',
    //                     0.0008, '#b6367a',
    //                     0.0012, '#51127c',
    //                     0.0016, '#00004c',
    //                     0.002, '#000'
    //                 ],
    //                 'fill-opacity': 0.75,
    //                 'fill-outline-color': 'transparent',
    //             },
    //             layout: {
    //                 visibility: 'none',
    //             },
    //         });
    //
    //         // empty layer for selected features for each layer
    //         map.addLayer({
    //             'id': `selected-${layerName}`,
    //             'type': 'fill',
    //             'source': layerName,
    //             'source-layer': layerName,
    //             'paint': {
    //                 'fill-outline-color': '#484896',
    //                 'fill-color': '#6e599f',
    //                 'fill-opacity': 0.5
    //             },
    //             'filter': ['in', 'id', '']  // default filter with no ids selected
    //         });  // plot drawn features on top of adundance tile layer ('gl-draw-polygon-fill-inactive.cold')
    //     });
    // }

    function addDrawControl() {
        const draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
                polygon: true,
                trash: true,
            }
        });
        map.addControl(draw);
    }

    function onDraw() {
        map.on('draw.create', (e) => {
            drawnPolygon = e.features[0];
            selectTiles();
        });
    }

    function selectTiles() {
        console.log(map.getLayer(selectedLayer));

        console.log(selectedLayer);

        // TODO Make dynamic layerName
        setTimeout(() => {
            const features = map.queryRenderedFeatures(bboxToPixel(drawnPolygon), { layers: [selectedLayer] });
            console.log(bboxToPixel(drawnPolygon));
            console.log(features);
            const props = features.map(feature => feature.properties);
            const unique = props.filter((elem, index) => props.findIndex(obj => obj.id === elem.id) === index);

            if (unique.length) {
                const mean = calculateMean(unique.map(val => val.relative_abundance));
                console.log(mean);
            } else {
                // TODO Return error
                // console.log('No values');
            }


            const filter = features.reduce((memo, feature) => {
                if (! (undefined === turf.intersect(feature, drawnPolygon))) {
                    // only add the property, if the feature intersects with the polygon drawn by the user
                    memo.push(feature.properties.id);
                }
                return memo;
            }, ['in', 'id']);

            map.setFilter(`selected-${selectedLayer}`, filter);
        }, 100);

    }

    // TODO Fix this to draw actual polygons and not just bbox
    function bboxToPixel(polygon) {
        // generate bounding box from polygon the user drew
        const bbox = turf.bbox(polygon);
        // convert geographic coordinates to pixel coordinates on the map for `queryRenderedFeatures` formatting
        // https://docs.mapbox.com/mapbox-gl-js/api/map/#map#project
        const nePixel = map.project([bbox[2], bbox[3]]);
        const swPixel = map.project([bbox[0], bbox[1]]);
        // formatted as [{x: 10, y: 10}, {x: 20, y: 20}]
        return [swPixel, nePixel];
    }

    function calculateMean(array) {
      return array.reduce((a, b) => a + b) / array.length;
    }

</script>

</body>
</html>