<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- JS -->
    <!-- Bootstrap styling -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js" integrity="sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>
    <!-- Mapbox, mapbox-draw, turf -->
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v1.13.0/mapbox-gl.js'></script>
    <script src='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.js'></script>
    <script src='https://npmcdn.com/@turf/turf/turf.min.js'></script>
    <!-- Jquery -->
    <script src="https://code.jquery.com/jquery-3.5.1.js" integrity="sha256-QWo7LDvxbWT2tbbQ97B53yJnYU3WhH/C8ycbRAkjPDc=" crossorigin="anonymous"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO" crossorigin="anonymous">
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v1.13.0/mapbox-gl.css' rel='stylesheet' />
    <link rel='stylesheet' href='https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-draw/v1.0.9/mapbox-gl-draw.css' type='text/css'/>
    <style>
        body {
            margin: 0;
            padding: 0;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        .dropdown {
            margin-right: 0.5rem;
        }

        .dropdown-menus {
            position: absolute;
            display: flex;
            top: 1rem;
            left: 1rem;
        }

        #info {
            position: absolute;
            left: 0.5rem;
            top: 3rem;
            color: whitesmoke;
            background: #191A1A;
            padding: 0.5rem;
            border-radius: 5px;
        }

    </style>
</head>
<body>

<div id='map'></div>

<!-- TODO Fix positioning for container holding menus and info box -->
<div class="dropdown-menus">
    <select id="select-bird" class="dropdown">
        <option value="none">Select Bird</option>
        <option value="ameavo">American Avocet</option>
        <option value="bknsti">Black-Necked Stilt</option>
    </select>
    <select id="select-time" class="dropdown">
        <option value="none">Select Variable</option>
        <option value="ra">Relative Abundance</option>
        <option value="pop">Percent of Population</option>
    </select>
    <select id="select-week" class="dropdown">
        <option value="none">Select Week</option>
        <option value="11">2018/03/15</option>
        <option value="12">2018/03/22</option>
        <option value="13">2018/03/29</option>
    </select>
<!--    <div class="slider-container">-->
<!--        <label for="select-week">Week</label>-->
<!--        <input type="range" min="11" max="13" value="11" class="slider" id="select-week">-->
<!--    </div>-->
</div>

<div id="info">
    Select variables and draw area on map to calculate mean
</div>

<script>
    mapboxgl.accessToken = 'pk.eyJ1IjoibGF1cmVub2xkaGFtMTIwMiIsImEiOiJjaW55dm52N2gxODJrdWtseWZ5czAyZmp5In0.YkEUt6GvIDujjudu187eyA';

    let week = '03-15';
    let bird = 'ameavo';
    let time = 'ra';

    let drawnPolygon = undefined;

    const tileMap = {
        bknsti_pop_11: '5fck411z',
        bknsti_pop_12: '7j0ypz8w',
        bknsti_pop_13: '0bgqnmvd',
        ameavo_pop_11: 'cq1dlt02',
        ameavo_pop_12: 'bcl9t1ic',
        ameavo_pop_13: '3xrib0y6',
        bknsti_ra_11: '6h7usi8o',
        bknsti_ra_12: '7or4n4wj',
        bknsti_ra_13: 'd1eishmw',
        ameavo_ra_11: 'b0loit4f',
        ameavo_ra_12: '9yrilm14',
        ameavo_ra_13: 'bjnreizi',
    };

    // TODO: Find out how weekly data will be accessed (will users be interested in just one week at a time, or how trends occur week over week?)
    // TODO: Should all birds/variables have the same legend/scale, or should it be custom for each one?

    function updateTileLayer() {

        if (bird !== '' && time !== '') {
            const layer = `${bird}_${time}_${week}`;

            Object.keys(tileMap).forEach(id => {
                if (id === layer) {
                    map.setLayoutProperty(id, 'visibility', 'visible');
                } else {
                    map.setLayoutProperty(id, 'visibility', 'none');
                }
            });
        }
    }

    // TODO Update calculations on variable changes
    $('#select-time').on('change', (e) => {
        time = e.target.value;
        updateTileLayer();
    });

    $('#select-bird').on('change', (e) => {
        // console.log(e.target.value);
        bird = e.target.value;
        updateTileLayer();
    });

    // // changet to 'change' event to only load on final resting spot and not every tick
    // $('#select-week').on('input', (e) => {
    //     week = e.target.value;
    //     updateTileLayer();
    // });
    // changet to 'change' event to only load on final resting spot and not every tick
    $('#select-week').on('change', (e) => {
        week = e.target.value;
        updateTileLayer();
    });

    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/dark-v9',
        center: [-75, 10], // starting position [lng, lat]
        zoom: 1, // starting zoom
        maxZoom: 9,
    });

    map.on('load', () => {
        // map.addSource('bknsti2', {
        //     type: 'vector',
        //     // scheme: 'tms',  // required for proper display of vector tiles
        //     // `countries:opengeo:countries` are the workspace (countries) and layer name (opengeo:countries) as uploaded in geoserver
        //     tiles: ['http://localhost:8080/data/ameavo_ra_3km/{z}/{x}/{y}.pbf'],
        //     // minZoom: 0,
        //     maxZoom: 15,
        // });
        // console.log(map.getSource('bknsti'));
        //
        // map.addLayer({
        //     id: 'bknsti2',
        //     type: 'fill',
        //     source: 'bknsti2',
        //     'source-layer': 'ameavo_ra',  // `title` from geoserver
        //     paint: {
        //         'fill-color': 'red',
        //         'fill-opacity': 0.25,
        //     }
        // });
        // console.log(map.getLayer('bknsti2'));
        //
        // map.on('click', 'bknsti2', (e) => {
        //     console.log(e.features[0].properties);
        // });


        // TODO Document issues with trying to merge all 52 weeks into same dataset (
        // TODO Deploy versions for github hosting (remote), github hosting (local/offline) and mapbox hosting, document
        // TODO Check in with Tom about google maps API
        // TODO Ask about other data vis packages currently in use - or do I need to figure that out?
        // TODO create Git tutorials for serving remotely with github pages, serving PBFs from local directory, tileServerGl, mapTiler?

        Object.entries(tileMap).forEach(([key, id]) => {

            // TODO Add condition for source-layer on relative abundance (includes week at end)
            // TODO dynamic updating of paint property
            const variable = key.slice(7, 10);
            const source =  key.slice(0, variable === 'pop' ? 10 : 9);

            map.addSource(key, {
                type: 'vector',
                url: `mapbox://laurenoldham1202.${id}`
            });

            map.addLayer({
                id: key,
                type: 'fill',
                source: key,
                'source-layer': source,
                paint: {
                    'fill-color': setFillColor(variable),
                    'fill-opacity': 0.75,
                    'fill-outline-color': 'transparent',
                },
                layout: {
                    visibility: 'none',
                },
            });

            map.on('mouseover', key, () => {
               map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseout', key, () => {
               map.getCanvas().style.cursor = 'grab';
            });

            map.on('click', key, (e) => {
                console.log(e.features[0].properties);
            });
        });

        addDrawControl();
        onDraw();

        updateTileLayer();


        // TODO add warning for large polygons at highest zoom levels - turn off autocalculation and prompt to recalculate?
        map.on('zoom', () => {
            const zoom = map.getZoom();
            const thresholds = [3, 5, 7];

            thresholds.forEach(threshold => {
                if ((zoom >= threshold) && (zoom <= threshold + 0.05) && drawnPolygon) {
                    console.log('update!');
                    selectTiles();
                }
            });
        });
    });

    function setFillColor(variable) {
        if (variable === 'pop') {
            return ['interpolate', ['linear'], ['get', 'percent_of_population'],
                0, 'rgba(255, 255, 255, 0.25)',
                0.0001, '#f1eef6',
                0.0004, '#d0d1e6',
                0.0008, '#a6bddb',
                0.0012, '#74a9cf',
                0.0016, '#2b8cbe',
                0.002, '#045a8d'
            ];
        } else {
            return ['interpolate', ['linear'], ['get', 'relative_abundance'],
                0, 'rgba(255, 255, 255, 0.25)',
                0.00001, '#fcfdbf',
                0.5, '#fc8761',
                1.5, '#b6367a',
                3, '#51127c',
                5, '#00004c',
                120, '#000'
            ];
        }

    }

    function getLayerName(time) {
        return `${bird}_${time}`;
    }

    // // TODO Might need to make layerName a dynamic input
    // function loadTiles() {
    //
    //     Object.entries(tileMap).forEach(([timeKey, tileId]) => {
    //         const layerName = `${bird}_${timeKey}`;
    //
    //
    //
    //         map.addSource(layerName, {
    //             type: 'vector',
    //             url: `mapbox://laurenoldham1202.${tileId}`
    //         });
    //
    //         map.addLayer({
    //             id: layerName,
    //             type: 'fill',
    //             source: layerName,
    //             'source-layer': layerName,
    //             paint: {
    //                 // 'fill-color': ['interpolate', ['linear'], ['get', 'relative_abundance'],
    //                 //     0, 'rgba(255, 255, 255, 1)',
    //                 //     0.00001, '#fcfdbf',
    //                 //     0.5, '#fc8761',
    //                 //     1.5, '#b6367a',
    //                 //     3, '#51127c',
    //                 //     5, '#00004c',
    //                 //     120, '#000'
    //                 // ],
    //                 'fill-color': ['interpolate', ['linear'], ['get', 'percent_of_population'],
    //                     0, 'rgba(255, 255, 255, 1)',
    //                     0.0001, '#fcfdbf',
    //                     0.0004, '#fc8761',
    //                     0.0008, '#b6367a',
    //                     0.0012, '#51127c',
    //                     0.0016, '#00004c',
    //                     0.002, '#000'
    //                 ],
    //                 'fill-opacity': 0.75,
    //                 'fill-outline-color': 'transparent',
    //             },
    //             layout: {
    //                 visibility: 'none',
    //             },
    //         });
    //
    //         // empty layer for selected features for each layer
    //         map.addLayer({
    //             'id': `selected-${layerName}`,
    //             'type': 'fill',
    //             'source': layerName,
    //             'source-layer': layerName,
    //             'paint': {
    //                 'fill-outline-color': '#484896',
    //                 'fill-color': '#6e599f',
    //                 'fill-opacity': 0.5
    //             },
    //             'filter': ['in', 'id', '']  // default filter with no ids selected
    //         });  // plot drawn features on top of adundance tile layer ('gl-draw-polygon-fill-inactive.cold')
    //     });
    // }

    function addDrawControl() {
        const draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
                polygon: true,
                trash: true,
            }
        });
        map.addControl(draw);

        // force delete any drawn object to bypass select mode bug
        $('.mapbox-gl-draw_trash').on('click', () => {
            draw.deleteAll();
            $('#info').text('');
            drawnPolygon = undefined;
        });
    }

    function onDraw() {
        map.on('draw.create', (e) => {
            drawnPolygon = e.features[0];
            selectTiles();
        });

        map.on('draw.update', (e) => {
            console.log(e.features[0]);
            drawnPolygon = e.features[0];
            selectTiles();
        });
    }

    function selectTiles() {


        // setTimeout(() => {
        //
        //     const layer = map.queryRenderedFeatures({layers: ['ameavo_ra_11']});
        //     console.log(layer);
        //
        //     layer.forEach(f => {
        //         // console.log(f);
        //         // // TODO need to preserve f properties
        //         const poly = turf.polygon(f.geometry.coordinates);
        //         // console.log(poly);
        //         poly.properties = f.properties;
        //         const t = turf.intersect(turf.polygon(drawnPolygon.geometry.coordinates), poly);
        //         if (t) {
        //             // console.log(poly);
        //             selected.ids.push(poly.properties.id);
        //             selected.pops.push(poly.properties.percent_population);
        //             selected.ras.push(poly.properties.relative_abundance);
        //             // TODO push properties to an array and set a filter for those ids on the map
        //             // TODO Test github.io deployment of subset of PBF tiles to see if missing tile 404s are returned
        //             // TODO Also test a http-server on locally generated PBFs in GM (will need to reformat column and output names)
        //
        //             // console.log(t);
        //         }
        //     });
        //     // f.geometry.coordinates is an array for each box coords
        //     console.log(selected);
        // }, 200);


        // TODO Add condition for when no layer is on the map
        const layer = `${bird}_${time}_${week}`;

        setTimeout(() => {
            // TODO Fix to draw polygons instead of bbox
            const features = map.queryRenderedFeatures(bboxToPixel(drawnPolygon), { layers: [layer] });
            const test = map.queryRenderedFeatures({ layers: [layer] });
            // console.log(features);
            // console.log(test);

            // TODO Adjust unique to pull in geom and not just props
            const geometry = {type: 'Polygon', coordinates: []};

            let intersection = [];
            features.forEach(feat => {
                // console.log(feat.geometry);
                // geometry.coordinates.push(feat.geometry.coordinates[0]);
                const poly = turf.polygon(feat.geometry.coordinates);
                poly.properties = feat.properties;
                // console.log('BEFORE', poly.properties.id);
                // const int = turf.intersect(turf.polygon(drawnPolygon.geometry.coordinates), poly);
                const int = turf.intersect(poly, turf.polygon(drawnPolygon.geometry.coordinates));
                if (int) {
                    // console.log('INTERSECTED!!:', poly.properties.id);
                    intersection.push(poly);
                    // geometry.coordinates.push(int.geometry.coordinates[0]);

                }
            });

            console.log(intersection);

            // console.log(drawnPolygon);
            // console.log(JSON.stringify(turf.polygon(drawnPolygon.geometry.coordinates)));
            // console.log(geometry);
            // console.log(JSON.stringify(turf.polygon(geometry.coordinates)));
            //
            // const drawnpoly = turf.polygon(drawnPolygon.geometry.coordinates);
            // const polys = turf.polygon(geometry.coordinates);
            // console.log(JSON.stringify(drawnpoly));
            // console.log(JSON.stringify(polys));
            //
            //
            // const int = turf.intersect(polys, drawnpoly);
            // const int2 = turf.intersect(drawnpoly, polys);
            // // console.log(int);
            // console.log(JSON.stringify(int));
            // console.log(JSON.stringify(int2));


            // console.log(features);
            const props = features.map(feature => feature.properties);
            const unique = props.filter((elem, index) => props.findIndex(obj => obj.id === elem.id) === index);
            // console.log(unique);
            if (unique.length) {
                const mean = calculateMean(unique.map(val => val[time === 'pop' ? 'percent_of_population' : 'relative_abundance']));
                // console.log(mean);
                $('#info').text('Mean for selected area: ' + mean.toFixed(6));
            } else {
                // TODO Return error
                console.log('No values');
            }


            // const filter = features.reduce((memo, feature) => {
            //     if (! (undefined === turf.intersect(feature, drawnPolygon))) {
            //         // only add the property, if the feature intersects with the polygon drawn by the user
            //         memo.push(feature.properties.id);
            //     }
            //     return memo;
            // }, ['in', 'id']);
            //
            // map.setFilter(`selected-${selectedLayer}`, filter);
        }, 100);

    }

    // TODO Fix this to draw actual polygons and not just bbox
    function bboxToPixel(polygon) {
        // generate bounding box from polygon the user drew
        const bbox = turf.bbox(polygon);
        // convert geographic coordinates to pixel coordinates on the map for `queryRenderedFeatures` formatting
        // https://docs.mapbox.com/mapbox-gl-js/api/map/#map#project
        const nePixel = map.project([bbox[2], bbox[3]]);
        const swPixel = map.project([bbox[0], bbox[1]]);
        // formatted as [{x: 10, y: 10}, {x: 20, y: 20}]
        return [swPixel, nePixel];
    }

    function calculateMean(array) {
        return array.reduce((a, b) => a + b) / array.length;
    }

</script>

</body>
</html>
